## **Problem**

https://leetcode.com/problems/longest-substring-without-repeating-characters/

給定一個字符串 $s$，求 $s$ 中最長的沒有重複字符的子串的長度。

字串的定義：\
所有由 $s$ 的頭部和尾部移除任意個（包括零個）字符所構成的新字符串都是 $s$的子串。

## **Observation**

定義 $s_i$ 爲 $s$ 的第 $i$ 個字符， $s_{i,j}$ 爲 $s$ 由 $i$ 到 $j$ （包括 $j$）的子串。

這是一個 dp 問題。

假設存在 $i,j$，使得 $s_{i,j}$ 是在 $j$ 結束，最長且符合條件的子串。\
這代表著 $s_{1,j},\dotsc,s_{i-1,j}$ 都存在重複的字符。

<!-- 對於任意的 $j$， $s_{1,j}$ 若有重複字符 $c$ ，而且他們的位置分別是 $c_1,c_2,\dotsc,c_k$\
若我們只考慮所有在 $j$ 結束的子串，那麼 $s_{1,j},\dotsc,s_{c_{k-1},j}$ 都不用考慮了。\
因爲他們都存在重複的字符 $c$。\
若沒有其他重複的字符，那麼 $s_{c_{k-1}+1,j}$ 就是在 $j$ 結束，最長且符合條件的子串。 -->

現在考慮 $j+1$，\
由於 $s_{1,j},\dotsc,s_{i-1,j}$ 存在重複的字符， $s_{1,j+1},\dotsc,s_{i-1,j+1}$ 也會有重複的字符。
* 如果 $s_{i,j}$ 裏有字符 $s_k$ 和 $s_{j+1}$ 相等，那麼 $s_{i,j+1},\dotsc,s_{k,j+1}$ 都存在重複的字符。\
  $s_{k+1,j+1}$ 就是在 $j+1$ 結束，最長且符合條件的子串。
* 如果 $s_{i,j}$ 裏沒有字符和 $s_{j+1}$ 相等，那麼\
  $s_{i,j+1}$ 就是在 $j+1$ 結束，最長且符合條件的子串。

由 $j=1$ 開始計算到 $j=\text{len}(s)$，\
所有在 $j$ 結束，最長且符合條件的子串中最長的一串就是答案。

要找出 $s_{i,j}$ 和 $s_{j+1}$ 相等的字符，\
構建一個 array 或 hashmap $A$，key 爲字符，value 爲字符在 $s$ 中的 index。
* 假設當 $j=k$ 時， $\forall c~A[c]$ 爲 $s_{0,k}$ 中字符 $c$ 最後出現的位置（`lastIndex`）。
* 當 $j=k+1$ 時，
  * 若 $A[s_{k+1}] \ge i$： $s_{k+1}$ 重複了，位置是 $A[s_{k+1}]$，\
    更新 $A[s_{k+1}] \leftarrow k+1$ 以維護 $A$ 的性質。

## **Solution**

`arr` 是 Observation 中的 $A$。\
`ans` 是目前最長的子串的長度。

在主循環中：
```cpp
if (arr[s[j]] >= i)
    i = arr[s[j]] + 1;
arr[s[j]] = j;
ans = max(ans, j - i + 1);
```
`arr[s[j]] >= i` 判斷在 $s_{i,j-1}$ 中有沒有和 $s_j$ 相等的字符，\
`arr[s[j]] = j` 更新 $A[s_j]$ 以維護 $A$ 的性質。\
`ans = max(ans, j - i + 1)` 若新的字串長度較大，更新 ans。

初始化：
```cpp
vector<int> arr(128, -1);
arr[s[0]] = 0;
int i = 0, ans = 1;
```
對於任何 $c$， $A[c]=-1$ 代表 $s_{i,j-1}$ 沒有和 $c$ 相等的字符。

由於循環由一開始，我們要做特判：
```cpp
if (s.length() <= 1)
    return s.length();
```